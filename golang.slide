Intro to Golang

Kevin Chen
TeslaGov
kevin@teslagovernment.com

* Goals

- Why Go?
- Compare and contrast Go and Java
- Language basics

* Go "Pros" (performance)

- Low memory footprint (2.875MiB at rest, as opposed to -Xms128m -Xmx128m)
  docker-compose up -d && docker stats clarakm-watchlist-api
- Docker image is 22 MB
- Fast to build
- Fast to test
- Feels sub-second vs 15 second startup time).

.link https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go.html Go vs Java benchmark
.link https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-node.html Go vs NodeJS
.link https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-python3.html Go vs Python

* Go "Pros" (libraries)

- Pull deps right from GitHub.
  go get -u -v ./...
- No Bintray learning curve (accounts, API keys, clicking "Publish")
- Versioning is as simple as tagging
- `$GOPATH` lets you live-edit libraries before you commit them

* Go "Pros" (code quality)

- Docs are managed and hosted for you
.link https://godoc.org/github.com/TeslaGov/clarakm-aws-events-go godoc
- Go report card
.link https://goreportcard.com/report/github.com/TeslaGov/clarakm-aws-events-go report card
- Automatic formatting ("spaces vs tabs" settled once and for all)
  go fmt .

* Go "Pros" (devops)

- Generates a single binary.
- No more JARs, classpaths, JVM.
- No JVM tuning (e.g., Xms, Xmx)
- Easy to deploy (with or without Docker).
  go build -o ./bin/clarakm-watchlist . && ./bin/clarakm-watchlist

* Go "Pros" (minimal dependencies)

- Frameworks are optional, not necessary
- Standard library is enough to build a REST API.
- No dealing with a web framework ("no accidentally exposed REST endpoints")
- No ORM, no wrestling with Hibernate bugs ("null fields won't return child associations")
- Adequate ecosystem of libraries (official AWS SDK, JWT library, etc)
- Testing is fast and simple. No test-utils necessary.

* Go "Pros" (language)

- Not exotic. Straightforward. Usually only one way to do things.
- Not magical. Nothing like repository.findOneByIdAndDeletedDateTimeIsNull().
- Imperative. No declarative annotations.
- Somewhat functional. Functions are first-class. (functions are like other variables).
- Interfaces. Composition over inheritance.
- Tuples. Nice error handling (no more exceptions).
- No function overloading (leads to less abstraction).
- Package-oriented rather than class-oriented (leads to fewer files).

.link https://yourbasic.org/golang/go-vs-java/ Go vs Java, language differences
.link https://yourbasic.org/golang/generics/ No generics - what to do instead
.link http://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/ pass by pointer vs pass by value
.link https://arhipov.net/golang/2016/03/12/shallow-copying-interface-values-in-go.html creating pointer clones

* Lines of Code

Ran `tokei` on our projects

- pix 86.4k LOC for 1136 Java files
- rampart 12k LOC for 200 Java files
- page 8.5k LOC for 115 Java files
- ups 7k LOC for 109 Java files
- rfi 2.2k LOC for 36 Java files
- zendesk 908 LOC for 30 Java files
- watchlist 2.6k for 17 Go files

* What's missing?

Go code is less declarative / less magical / more imperative.

- No declarative annotations for resource validation or scheduled tasks
- No ORM (large queries for nested resources, manual TX management)
- No DB migrations
- Fewer layers (I've combined controller, security, and service layers)
- Library versioning strategy (vgo)

Libraries to the rescue:

.link https://github.com/go-ozzo/ozzo-validation resource validation
.link https://github.com/jinzhu/gorm ORM
.link https://github.com/mattes/migrate migrate - DB migrations
.link https://github.com/pressly/goose goose - DB migrations

* Hello World

.link https://play.golang.org/p/BwvOWBtAY53 functions, fmt.Printf
.code hello-world.txt

* "Objects"

.link https://play.golang.org/p/to1jaJMWG-W doing "objects" with structs and receiver methods
.code objects.go

* Server example

.code server.txt
