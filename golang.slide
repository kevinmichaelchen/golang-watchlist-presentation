Intro to Golang

Kevin Chen
TeslaGov
kevin@teslagovernment.com

* Goals

- Why Go?
- Language basics
- Compare and contrast Go and Java

* Go "Pros" (performance)

- Lightweight (15mb vs 128mb), fast, scalable.
- Fast to build, fast to test (feels sub-second vs 15 second startup time). 

.link https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go.html Go vs Java benchmark
.link https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-node.html Go vs NodeJS
.link https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-python3.html Go vs Python

* Go "Pros" (libraries)

- Pull deps right from GitHub.
  go get -u -v ./...
- No Bintray learning curve (accounts, API keys, clicking "Publish")
- Versioning is as simple as tagging
- `$GOPATH` lets you live-edit libraries before you commit them
- Docs are managed for you
  https://godoc.org/github.com/TeslaGov/clarakm-aws-events-go
- Go report card
  https://goreportcard.com/report/github.com/TeslaGov/clarakm-aws-events-go

* Go "Pros" (devops)

- Generates a single binary.
- No more JARs, classpaths, JVM.
- Easy to deploy (with or without Docker).
  go build -o ./bin/clarakm-watchlist .
- Automatic formatting
  go fmt .

* Go "Pros" (frameworks)

- Fewer dependencies
- Standard library is enough to build a REST API.
- No dealing with a web framework ("no accidentally exposed REST endpoints")
- No ORM, no wrestling with Hibernate bugs ("null fields won't return child associations")
- Adequate ecosystem of libraries (official AWS SDK, JWT library, etc)
- Testing is fast and simple. No test-utils necessary.

* Go "Pros" (language)

- Tuples. Nice error handling (no more exceptions).
- No function overloading (leads to less abstraction).
- Package-oriented rather than class-oriented (leads to fewer files).

* Lines of Code

Ran `tokei` on our projects

- watchlist 2.5k for 17 Go files
- page 8.5k LOC for 115 Java files
- ups 7k LOC for 109 Java files
- rfi 2.2k LOC for 36 Java files
- zendesk 908 LOC for 30 Java files

* Cons

In general, my Go code is less declarative / more imperative.

- No declarative annotations for resource validation or scheduled tasks
- No ORM (large queries for nested resources, manual TX management)
- No DB migrations
- Fewer layers (I've combined controller, security, and service layers)
- Library versioning strategy (vgo)

Libraries to the rescue:

.link https://github.com/go-ozzo/ozzo-validation resource validation
.link https://github.com/jinzhu/gorm ORM
.link https://github.com/mattes/migrate migrate - DB migrations
.link https://github.com/pressly/goose goose - DB migrations

* Hello World

.link https://play.golang.org/p/BwvOWBtAY53 functions, fmt.Printf
.code hello-world.txt

* "Objects"

.link https://play.golang.org/p/to1jaJMWG-W doing "objects" with structs and receiver methods
.code objects.go

* Server example

.code server.txt
